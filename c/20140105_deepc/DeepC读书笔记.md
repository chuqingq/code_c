# 【Deep C (and C++)】深入理解C/C++(1)--读书笔记
http://blog.csdn.net/rockics/article/details/7015067

## 没有include stdio.h
* C++编译器将会拒绝这段代码，因为C++要求必须显示定义所有的函数。
*  有一些特别的C编译器会为printf()函数创建隐式定义，把这个文件编译成目标文件。再跟标准库链接的时候，它将寻找printf()函数的定义，以此来匹配隐式的定义。
* 函数声明参数：C语言中，使用void来指示函数声明中不需要参数。如果这样声明函数int f()，那表明f()函数可以有任意多的参数（TODO），虽然你可能打算说明函数不需要参数，但这里并非你意。如果你的意思是函数不需要参数，显式的使用void，并没有什么坏处。
* C标准指出源代码必须要以新的一行结束

## 函数中的static变量
* C标准说明，静态变量会被初始化为0

## 函数中的非静态变量（自动变量）
* 理论上你会得到三个垃圾值
* 因为自动变量一般都会在运行栈中分配，三次调用foo函数的时候，a有可能存在同一内存空间，因此你会得到三个连续的值，如果你没有进行任何编译优化的话
* 如果你运行于debug模式，运行时机制会把你的栈空间全部初始化为0
* 为什么静态变量会被初始化为0，而自动变量却不会被初始化？
    * 把自动变量初始化为0的代价，将会增加函数调用的代价。C语言非常注重运行速度。
    * 然而，把全局变量区初始化为0，仅仅在程序启动时候产生成本。这也许是这个问题的主要原因。
    * 更精确的说，C++并不把静态变量初始化为0，他们有自己的默认值，对于原生类型（native types）来说，这意味着0。

## 全局变量
* 变量还是静态分配，并且被初始化为0
*  这和链接器(linker)有关。这里的变量可以被其他的编译单元访问，也就是说，链接器可以让其他的目标文件访问这个变量。但是如果加了static，那么这个变量就变成该编译单元的局部变量了，其他编译单元不可以通过链接器访问到该变量。

## (1)结束

